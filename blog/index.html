<!DOCTYPE html>
<html lang="en" encoding="utf-8">

<head>
    <meta charset="UTF-8">
    <title>Amaso Melas</title>
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;global.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="icon" type="image/x-icon" href="/icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
</head>


<body>
    <div class="body">
        <header>
            <a href="/"><h1><span class="icon"></span>Amaso Melas</h1></a>
        </header>
        <section class="section">
            <div class="container">
                
<h1 class="title">
    Posts
</h1>
<ul>
    <!-- If you are using pagination, section.pages will be empty.
    You need to use the paginator object -->
    
    <li>
        <strong>2026-02-13</strong> ==> <a href="https://osamasalem.github.io/blog/windows-crate/">Windows crate: The good, the bad and the awkward.</a>
        <p><p>The <a rel="noopener external" target="_blank" href="https://crates.io/crates/windows">windows crate</a> is the Rust package from Microsoft that provides Rust-friendly bindings to the Windows API, which is essential for any kind of serious system programming on Windows.</p> <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;windows-crate&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
    <li>
        <strong>2025-10-29</strong> ==> <a href="https://osamasalem.github.io/blog/creating-couple-iterator/">Creating couple iterator: Another dive into unsafe Rust!!</a>
        <p><p>I was working on an N-body simulation in Rust, and I noticed a gap:
Rust, out of the box, does not provide an iterator that can safely yield pairs of mutable references (<code>&amp;mut T</code>) from a slice - without violating Rust’s borrowing rules.</p>
<p>So, I decided to implement one myself and dive once again into the world of unsafe Rust.</p> <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;creating-couple-iterator&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
    <li>
        <strong>2025-08-22</strong> ==> <a href="https://osamasalem.github.io/blog/moving-the-unmovable/">Moving the unmovable: how to transfer ownership in Rust</a>
        <p><p>Good software design often requires carefully modeling ownership and data flow from the start. In Rust, this is especially important because ownership is at the core of the language. Sometimes, though, you need to move ownership of an object around- and for many developers coming from other languages, this feels unfamiliar and even frustrating.</p>
<p>This post discusses techniques for moving owned objects in Rust.&hellip;
</p>
 <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;moving-the-unmovable&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
    <li>
        <strong>2025-05-12</strong> ==> <a href="https://osamasalem.github.io/blog/unsafe-rust/">Unsafe Rust</a>
        <p><p>Back in college, I overheard a group of students discussing something interesting: C#, Microsoft's proposed alternative to C++ and their own dialect of Java. I asked, “What about accessing low-level data types and structures?” Someone responded, “You can use <code>unsafe</code> blocks to access pointers freely and interoperate with the newly introduced .NET CLR.” The CLR, of course, allows you to write code in VB, C#, or even C++.</p> <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;unsafe-rust&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
    <li>
        <strong>2025-05-07</strong> ==> <a href="https://osamasalem.github.io/blog/rethinking-gc/">Criticizing Automated Garbage Collection</a>
        <p><p>Garbage collection (GC) is widely considered a hallmark of modern programming languages, promoted for its ability to simplify development and reduce memory-related bugs. Its presence in languages such as Java, C#, Go, and JavaScript has become ubiquitous.</p>
<p>However,&hellip;
</p>
 <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;rethinking-gc&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
    <li>
        <strong>2025-05-06</strong> ==> <a href="https://osamasalem.github.io/blog/circus-prgramming-in-multicore-era/">Circus: Yet Another Programming Take</a>
        <p><p>Since the mid-20th century, programming languages have largely retained the same fundamental structure as when they were first invented. But as technology evolves steadily—and with hardware hitting the physical limits of single-core scaling and shifting towards multi-core architectures-there is a growing need to rethink how we approach computation.&hellip;
</p>
 <a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;blog&#x2F;circus-prgramming-in-multicore-era&#x2F;#continue-reading"> Continue...</a></p>

    </li>
    
</ul>

            </div>
        </section>
        <footer>

            <p>
                    <a href="/"><i class="fa fa-home" aria-hidden="true"></i> Home</a>
                | <a target="_blank" href="https://www.linkedin.com/in/osama-salem-5a432546/"><i class="fa fa-linkedin" aria-hidden="true"></i> LinkedIn</a>
                | <a target="_blank" href="https://github.com/osamasalem"><i class="fa fa-github" aria-hidden="true"></i> Github</a>
                | <a target="_blank" href="https://x.com/MelasAmaso"><i class="fa-brands fa-x-twitter" aria-hidden="true"></i>  X</a>
            </p>
            <p>Powered by <a target="_blank" href="https://www.getzola.org/">Zola©</a> </p>

        </footer>
    </div>
</body>

</html>
