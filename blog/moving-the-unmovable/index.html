<!DOCTYPE html>
<html lang="en" encoding="utf-8">

<head>
    <meta charset="UTF-8">
    <title>Osama Salem</title>
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;global.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="icon" type="image/x-icon" href="/icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
</head>


<body>
    <div class="body">
        <header>
            <a href="/"><h1><span class="icon"></span>Amaso</h1></a>
        </header>
        <section class="section">
            <div class="container">
                
<h1 class="title">
    Moving the unmovable: how to transfer ownership in Rust
</h1>



<a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;tags&#x2F;programming&#x2F;" class="tag">  #programming</a>


<a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;tags&#x2F;rust&#x2F;" class="tag">  #rust</a>

<p class="subtitle"><strong>2025-08-22</strong></p>
<p>Good software design often requires carefully modeling ownership and data flow from the start. In Rust, this is especially important because ownership is at the core of the language. Sometimes, though, you need to move ownership of an object around- and for many developers coming from other languages, this feels unfamiliar and even frustrating.</p>
<p>This post discusses techniques for moving owned objects in Rust.<span id="continue-reading"></span> By default, Rust prevents you from simply “grabbing” an object out of another, because doing so might break invariants and leave objects in an invalid state.</p>
<p>Rust’s ownership model is built on two fundamental rules:</p>
<ul>
<li>No object may ever exist in an invalid state.</li>
<li>Every value has exactly one owner.</li>
</ul>
<p>From these rules, it follows that moving a child object out of its parent is normally prohibited, since it could invalidate the parent. In other words, Rust enforces a solid ownership tree: once objects are instantiated, their structure usually remains fixed.</p>
<blockquote>
<p>Note: We’re talking here about owned values, not primitives or Copy types.</p>
</blockquote>
<p>To explore the options, we’ll use a computer setup as our example: a computer must have a monitor. Throughout the post we’ll see how to “move the monitor out of the setup” under different circumstances.</p>
<p>But first, Let's see the problem, and illustrate how Rust refuses to move objects around</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Child</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Parent </span><span>{
</span><span>    child</span><span style="color:#bfbab0cc;">:</span><span> Child,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">lets_move_the_unmovable</span><span>(</span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(Parent, Child) {
</span><span>    </span><span style="color:#ff7733;">let</span><span> child </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#f29668;">.</span><span>child</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>this code will cause this comiler error</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>error[E0382]: use of partially moved value: `parent`
</span><span> --&gt; src\main.rs:8:6
</span><span>  |
</span><span>7 |     let child = parent.child;
</span><span>  |                 ------------ value partially moved here
</span><span>8 |     (parent, child)
</span><span>  |      ^^^^^^ value used here after partial move
</span><span>  |
</span><span>  = note: partial move occurs because `parent.child` has type `Child`, which does not implement the `Copy` trait
</span><span>
</span></code></pre>
<h2 id="0-other-means">0. Other means</h2>
<p>Before trying to move ownership directly, consider alternatives:</p>
<ul>
<li>References: Shared (<code>&amp;T</code>) or exclusive (<code>&amp;mut T</code>) references are often enough.</li>
<li>Shared ownership: If multiple objects need access, use <code>Arc&lt;T&gt;</code> or <code>Arc&lt;RefCell&lt;T&gt;&gt;</code>.</li>
<li>Cloning: <code>.clone()</code> gives you a copy (sometimes expensive, but valid). This doesn’t move the original, but in some cases that’s exactly what you want.</li>
</ul>
<h2 id="1-break-the-whole-setup-to-get-the-child">1. Break the whole setup to get the child</h2>
<p>If you really want to extract a child, the simplest way is to destroy the parent.
For example: to get the monitor, throw away the whole computer setup. simple like that!!
consider this snippet</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Child</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Parent </span><span>{
</span><span>    child</span><span style="color:#bfbab0cc;">:</span><span> Child,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">drop_parent_take_child</span><span>(</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>((), Child) {
</span><span>    </span><span style="color:#ff7733;">let</span><span> child </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#f29668;">.</span><span>child</span><span style="color:#bfbab0cc;">; </span><span style="font-style:italic;color:#5c6773;">// this is allowed as the funtion takes the ownership of
</span><span>                              </span><span style="font-style:italic;color:#5c6773;">// the parent will be destructed at the end of this function
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// theoritical drop(parent)
</span><span>    ((</span><span style="font-style:italic;color:#5c6773;">/*No parent*/</span><span>)</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>This works, but if you had a deep ownership tree, you’d have to destroy the entire structure just to reach a leaf value- sometimes impractical.</p>
<h2 id="2-barter-with-the-owner">2. Barter with the owner</h2>
<p>What if you want the monitor, but don’t want to harm the computer? You can replace the monitor with similar one.</p>
<p>check this</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">replace_with_new_one</span><span>(</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(Parent, Child) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// take the object
</span><span>    </span><span style="color:#ff7733;">let</span><span> child </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#f29668;">.</span><span>child</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// compensate the owner
</span><span>    parent</span><span style="color:#f29668;">.</span><span>child </span><span style="color:#f29668;">=</span><span> Child</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>though the idiomatic way may be something like this:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">swap</span><span>(</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(Parent, Child) {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> child </span><span style="color:#f29668;">=</span><span> Child</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// barter objects
</span><span>    mem</span><span style="color:#f29668;">::</span><span>swap(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> child</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> parent</span><span style="color:#f29668;">.</span><span>child)</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>If <code>Child</code> struct implements <code>Default</code> trait, you can use this API call to replace the child object with the default, something like this</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Default)]
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Child</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">replace_with_default</span><span>(</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(Parent, Child) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// hey owner!! I will take this and you can use the default
</span><span>    </span><span style="color:#ff7733;">let</span><span> child </span><span style="color:#f29668;">= </span><span>mem</span><span style="color:#f29668;">::</span><span>take(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> parent</span><span style="color:#f29668;">.</span><span>child)</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>Note: Usually, you <code>clone</code> the objects in Rust which is similar to bartering. but instead we get the clone out from the owned value, which we can not consider it as transfer ownership.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Clone)]
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">Child</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">replace_with_default</span><span>(</span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> Parent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(Parent, Child) {
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> parent</span><span style="color:#f29668;">.</span><span>child</span><span style="color:#f29668;">.</span><span style="color:#f07178;">clone</span><span>())
</span><span>}
</span></code></pre>
<h2 id="3-replace-it-with-a-placeholder">3. Replace it with a placeholder</h2>
<p>Another approach is to make the parent more flexible. Instead of requiring a child, allow for the absence of one with Option.</p>
<p>consider this one:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">TolerantParent </span><span>{
</span><span>    child</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;Child&gt;,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">take_and_fill_the_gap</span><span>(</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">:</span><span> TolerantParent) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(TolerantParent, </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;Child&gt;) {
</span><span>    </span><span style="color:#ff7733;">if let</span><span> child </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#f29668;">.</span><span>child</span><span style="color:#f29668;">.</span><span style="color:#f07178;">take</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>Now, the parent remains valid even if the child is missing. The cost is that you’ve moved some safety checks from compile time to runtime- None means “the child is gone.”</p>
<h2 id="4-in-containers-things-can-be-easier">4. In containers things can be easier</h2>
<p>With collections, Rust often provides convenient APIs. For example, <code>Vec::remove</code> gives you ownership of an element while maintaining the rest:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">take_one_of_vec</span><span>(</span><span style="color:#f29718;">parent</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Child&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Child&gt;, Child) {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> parent </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">let</span><span> child </span><span style="color:#f29668;">=</span><span> parent</span><span style="color:#f29668;">.</span><span style="color:#f07178;">remove</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    (parent</span><span style="color:#bfbab0cc;">,</span><span> child)
</span><span>}
</span></code></pre>
<p>If your computer setup has multiple monitors, taking one doesn’t invalidate the rest.</p>
<p>But pay attention, that this may obey the general algorith call complexity cost. so if you are okay with that, no problem !!</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>We’ve walked through several techniques for transferring ownership in Rust. The language forces us to preserve invariants and prevent invalid states- but within those rules, there are multiple strategies to move values around safely.</p>
<p>Even if none of these cases match your exact problem, I hope this gave you a clearer sense of how Rust’s ownership works. Keeping invariants valid at all times is exactly what makes Rust special in resource management.</p>


            </div>
        </section>
        <footer>

            <p>
                    <a href="/"><i class="fa fa-home" aria-hidden="true"></i> Home</a>
                | <a target="_blank" href="https://www.linkedin.com/in/osama-salem-5a432546/"><i class="fa fa-linkedin" aria-hidden="true"></i> LinkedIn</a>
                | <a target="_blank" href="https://github.com/osamasalem"><i class="fa fa-github" aria-hidden="true"></i> Github</a>
                | <a target="_blank" href="https://x.com/MelasAmaso"><i class="fa-brands fa-x-twitter" aria-hidden="true"></i>  X</a>
                | <a target="_blank" href="/about"><i class="fa fa-address-card" aria-hidden="true"></i>  About</a>
            </p>
                <p>Copyright ©  to Osama Salem 2025</p>
            <p>Powered by <a target="_blank" href="https://www.getzola.org/">Zola©</a> </p>

        </footer>
    </div>
</body>

</html>
