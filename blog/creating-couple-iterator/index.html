<!DOCTYPE html>
<html lang="en" encoding="utf-8">

<head>
    <meta charset="UTF-8">
    <title>Osama Salem</title>
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;global.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="icon" type="image/x-icon" href="/icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
</head>


<body>
    <div class="body">
        <header>
            <a href="/"><h1><span class="icon"></span>Amaso</h1></a>
        </header>
        <section class="section">
            <div class="container">
                
<h1 class="title">
    Creating couple iterator: Another dive into unsafe Rust!!
</h1>



<a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;tags&#x2F;programming&#x2F;" class="tag">  #programming</a>


<a href="https:&#x2F;&#x2F;osamasalem.github.io&#x2F;tags&#x2F;rust&#x2F;" class="tag">  #rust</a>

<p class="subtitle"><strong>2025-10-29</strong></p>
<p>I was working on an N-body simulation in Rust, and I noticed a gap:
Rust, out of the box, does not provide an iterator that can safely yield pairs of mutable references (&amp;mut T) from a slice - without violating Rust’s borrowing rules.</p>
<p>So, I decided to implement one myself and dive once again into the world of unsafe Rust.</p>
<span id="continue-reading"></span>
<p>In my simulation, I needed a way to handle pairwise interactions - forces and collisions between two bodies - and update their positions and velocities through mutable references.
This pattern is quite common in game development and physics simulations.</p>
<p>Imagine we have:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">let</span><span> myvec </span><span style="color:#f29668;">= </span><span style="color:#f07178;">vec!</span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">3</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">4</span><span>]</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>We want an iterator that produces pairs of distinct mutable references:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">2</span><span>)
</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">3</span><span>)
</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">4</span><span>)
</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">3</span><span>)
</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">4</span><span>)
</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">3</span><span style="color:#bfbab0cc;">,</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">4</span><span>)
</span></code></pre>
<p>In safe Rust, this is impossible- you can’t create two mutable references into the same slice at once without splitting it first.
The borrow checker prevents this to ensure aliasing safety.</p>
<p>However, we know that getting mutable references to different elements is perfectly safe - their memory regions don’t overlap. So, unsafe code is the only way forward.</p>
<h2 id="implementation">Implementation</h2>
<blockquote>
<p>⚠️ DISCLAIMER: This code is for demonstration purposes only. It is not optimized or production-ready, but it highlights the concept clearly.</p>
</blockquote>
<p>Let’s start with the iterator structure.
A standard Rust slice iterator internally uses a <code>NonNull&lt;T&gt;</code> pointer to track the current element and walks until it reaches the end pointer.</p>
<p>Here, we’ll maintain two pointers - one for each element of the pair:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Clone)]
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">CouplesIterator</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; {
</span><span>    first</span><span style="color:#bfbab0cc;">: </span><span>NonNull&lt;T&gt;, </span><span style="font-style:italic;color:#5c6773;">// the first element in the pair tuple
</span><span>    second</span><span style="color:#bfbab0cc;">: </span><span>NonNull&lt;T&gt;, </span><span style="font-style:italic;color:#5c6773;">// the second element in the pair tuple
</span><span>    end</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">*mut</span><span> T, </span><span style="font-style:italic;color:#5c6773;">// the end pointer
</span><span>    _dummy</span><span style="color:#bfbab0cc;">: </span><span>PhantomData&lt;</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut &#39;a</span><span> T&gt;, </span><span style="font-style:italic;color:#5c6773;">// a friend to cover the presence of &#39;a
</span><span>}
</span></code></pre>
<p>The logic is simple:</p>
<ul>
<li><code>first</code> starts at the first element,</li>
<li><code>second</code> starts one step ahead,</li>
<li><code>second</code> advances until it reaches the end,</li>
</ul>
<p>when it does, first advances by one, and second resets to one step ahead of it.</p>
<p>If the slice has fewer than two elements, we stop immediately.</p>
<p>Here’s a simplified version of <code>next()</code>:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;a</span><span>&gt; Iterator </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">CouplesIterator</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; {
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Item </span><span style="color:#f29668;">= </span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut</span><span> T</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut</span><span> T)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&gt; {
</span><span>
</span><span>        </span><span style="color:#ff7733;">unsafe </span><span>{
</span><span>            </span><span style="font-style:italic;color:#5c6773;">//...
</span><span>
</span><span>            </span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_ptr</span><span>() </span><span style="color:#f29668;">==</span><span> end {
</span><span>                </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_ptr</span><span>() </span><span style="color:#f29668;">==</span><span> end</span><span style="color:#f29668;">.</span><span style="color:#f07178;">sub</span><span>(</span><span style="color:#f29718;">1</span><span>) {
</span><span>                </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">;
</span><span>            }
</span><span>
</span><span>            </span><span style="color:#ff7733;">let</span><span> first </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>            </span><span style="color:#ff7733;">let</span><span> second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            </span><span style="font-style:italic;color:#39bae6;">Some</span><span>((first</span><span style="color:#bfbab0cc;">,</span><span> second))
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span></code></pre>
<h2 id="zst-whooow-ghost">ZST, Whooow!!! 👻</h2>
<p>This works fine for types with a nonzero size (e.g., i32, f64, etc.), but what happens if the type has zero size - like the unit type () or an empty struct?</p>
<p>consider this</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">ZeroSizedTypes</span><span style="color:#bfbab0cc;">;</span><span>W
</span></code></pre>
<p>For ZSTs, all instances have the same address (Rust guarantees they’re logically distinct but occupy no memory).
This means our pointer-based approach breaks down- first, second, and end all point to the same location!</p>
<p>To handle this safely, we can fall back to an iteration counter instead of pointer arithmetic.The total number of pairs is <code>n * (n - 1) / 2</code>, where <code>n</code> is the slice length.</p>
<p>We can encode both cases (ZST and non-ZST) using an enum:</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">enum </span><span style="color:#59c2ff;">IterationMode</span><span>&lt;T&gt; {
</span><span>    Count(</span><span style="color:#ff7733;">usize</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    Pointer(</span><span style="color:#ff7733;">*mut</span><span> T)</span><span style="color:#bfbab0cc;">,
</span><span>}
</span></code></pre>
<p>(Interestingly, the Rust standard library optimizes this internally - since <code>*mut T</code> and <code>usize</code> have the same size and alignment, it reuses the same field for both cases.)</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">if </span><span>mem</span><span style="color:#f29668;">::</span><span>size_of</span><span style="color:#f29668;">::</span><span>&lt;T&gt;() </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">/* Zero size */
</span><span>} </span><span style="color:#ff7733;">else </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">/* Non zero size */
</span><span>}
</span></code></pre>
<p>You might wonder:</p>
<blockquote>
<p>“If both pointers refer to the same object, isn’t it UB to create two mutable references to it?”</p>
</blockquote>
<p>Normally yes- except for ZSTs. Since ZSTs occupy no memory, aliasing doesn’t lead to any data overlap or race conditions. as they are all ending up being no-ops.</p>
<p>So, we can safely create multiple &amp;mut references to the same ZST value.</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">SliceEx</span><span>&lt;&#39;a, T&gt;
</span><span>where
</span><span>    T: Sized,
</span><span>{
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">couples_mut</span><span>(</span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span>CouplesIterator&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>}
</span><span>
</span><span style="color:#ff7733;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; SliceEx&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; </span><span style="color:#ff7733;">for </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a </span><span style="color:#59c2ff;">mut</span><span> [</span><span style="color:#59c2ff;">T</span><span>] {
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">couples_mut</span><span>(</span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span>CouplesIterator&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; {
</span><span>        </span><span style="color:#ff7733;">unsafe </span><span>{
</span><span>            </span><span style="color:#ff7733;">let</span><span> len </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span style="color:#f07178;">len</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            </span><span style="color:#ff7733;">let</span><span> first </span><span style="color:#f29668;">= </span><span>NonNull</span><span style="color:#f29668;">::</span><span>from_mut(</span><span style="font-style:italic;color:#39bae6;">self</span><span>)</span><span style="color:#f29668;">.</span><span style="color:#f07178;">cast</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            </span><span style="color:#ff7733;">let </span><span>(second</span><span style="color:#bfbab0cc;">,</span><span> end) </span><span style="color:#f29668;">= </span><span style="color:#ff7733;">if </span><span>mem</span><span style="color:#f29668;">::</span><span>size_of</span><span style="color:#f29668;">::</span><span>&lt;T&gt;() </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>                </span><span style="color:#ff7733;">let</span><span> count </span><span style="color:#f29668;">=</span><span> len </span><span style="color:#f29668;">*</span><span> len</span><span style="color:#f29668;">.</span><span style="color:#f07178;">wrapping_sub</span><span>(</span><span style="color:#f29718;">1</span><span>) </span><span style="color:#f29668;">/</span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">;
</span><span>                (first</span><span style="color:#bfbab0cc;">, </span><span>IterationMode</span><span style="color:#f29668;">::</span><span>Count(count))
</span><span>            } </span><span style="color:#ff7733;">else if</span><span> len </span><span style="color:#f29668;">&lt; </span><span style="color:#f29718;">2 </span><span>{
</span><span>                (first</span><span style="color:#bfbab0cc;">, </span><span>IterationMode</span><span style="color:#f29668;">::</span><span>Count(</span><span style="color:#f29718;">0</span><span>))
</span><span>            } </span><span style="color:#ff7733;">else </span><span>{
</span><span>                (
</span><span>                    first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>                    IterationMode</span><span style="color:#f29668;">::</span><span>Pointer(first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(len)</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_ptr</span><span>())</span><span style="color:#bfbab0cc;">,
</span><span>                )
</span><span>            }</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>            CouplesIterator {
</span><span>                first</span><span style="color:#bfbab0cc;">,
</span><span>                second</span><span style="color:#bfbab0cc;">,
</span><span>                end</span><span style="color:#bfbab0cc;">,
</span><span>                _dummy</span><span style="color:#bfbab0cc;">:</span><span> PhantomData</span><span style="color:#bfbab0cc;">,
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Clone)]
</span><span style="color:#ff7733;">enum </span><span style="color:#59c2ff;">IterationMode</span><span>&lt;T&gt; {
</span><span>    Count(</span><span style="color:#ff7733;">usize</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    Pointer(</span><span style="color:#ff7733;">*mut</span><span> T)</span><span style="color:#bfbab0cc;">,
</span><span>}
</span><span>
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Clone)]
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">CouplesIterator</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; {
</span><span>    first</span><span style="color:#bfbab0cc;">: </span><span>NonNull&lt;T&gt;,
</span><span>    second</span><span style="color:#bfbab0cc;">: </span><span>NonNull&lt;T&gt;,
</span><span>    end</span><span style="color:#bfbab0cc;">: </span><span>IterationMode&lt;T&gt;,
</span><span>    _dummy</span><span style="color:#bfbab0cc;">: </span><span>PhantomData&lt;</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut</span><span> T&gt;,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; Iterator </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">CouplesIterator</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, T&gt; {
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Item </span><span style="color:#f29668;">= </span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut</span><span> T</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut</span><span> T)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&gt; {
</span><span>        </span><span style="color:#ff7733;">unsafe </span><span>{
</span><span>            </span><span style="color:#ff7733;">match </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>end {
</span><span>                IterationMode</span><span style="color:#f29668;">::</span><span>Count(</span><span style="color:#ff7733;">ref mut</span><span> count) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>                    </span><span style="color:#ff7733;">if </span><span style="color:#f29668;">*</span><span>count </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>                        </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">;
</span><span>                    }
</span><span>                    </span><span style="color:#f29668;">*</span><span>count </span><span style="color:#f29668;">-= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="color:#ff7733;">let</span><span> first </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="color:#ff7733;">let</span><span> second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">Some</span><span>((first</span><span style="color:#bfbab0cc;">,</span><span> second))
</span><span>                }
</span><span>                IterationMode</span><span style="color:#f29668;">::</span><span>Pointer(end) </span><span style="color:#f29668;">=&gt; </span><span>{
</span><span>                    </span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_ptr</span><span>() </span><span style="color:#f29668;">==</span><span> end {
</span><span>                        </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                        </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>                    }
</span><span>
</span><span>                    </span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_ptr</span><span>() </span><span style="color:#f29668;">==</span><span> end</span><span style="color:#f29668;">.</span><span style="color:#f07178;">sub</span><span>(</span><span style="color:#f29718;">1</span><span>) {
</span><span>                        </span><span style="color:#ff7733;">return </span><span style="font-style:italic;color:#39bae6;">None</span><span style="color:#bfbab0cc;">;
</span><span>                    }
</span><span>
</span><span>                    </span><span style="color:#ff7733;">let</span><span> first </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>first</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="color:#ff7733;">let</span><span> second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">as_mut</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>second</span><span style="color:#f29668;">.</span><span style="color:#f07178;">add</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>                    </span><span style="font-style:italic;color:#39bae6;">Some</span><span>((first</span><span style="color:#bfbab0cc;">,</span><span> second))
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#bfbab0cc;">#</span><span>[</span><span style="color:#ffb454;">derive</span><span>(Debug</span><span style="color:#bfbab0cc;">,</span><span> Clone)]
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">S</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let</span><span> k</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span>[</span><span style="color:#ff7733;">i32</span><span>] </span><span style="color:#f29668;">= &amp;</span><span style="color:#ff7733;">mut </span><span>[</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">2</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">3</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">4</span><span>]</span><span style="color:#bfbab0cc;">;
</span><span>    k</span><span style="color:#f29668;">.</span><span style="color:#f07178;">couples_mut</span><span>()</span><span style="color:#f29668;">.</span><span style="color:#f07178;">for_each</span><span>(|(</span><span style="color:#f29718;">a</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">b</span><span>)| mem</span><span style="color:#f29668;">::</span><span>swap(a</span><span style="color:#bfbab0cc;">,</span><span> b))</span><span style="color:#bfbab0cc;">;
</span><span>}
</span><span>
</span></code></pre>
<h2 id="final-words">Final words</h2>
<p>I really enjoyed this deep dive - tinkering at a low level in Rust is always fun and enlightening.
This experiment revealed interesting edge cases, especially around ZST aliasing and iterator design in unsafe Rust.</p>
<p>I made a few assumptions and simplifications for clarity, so if you spot something worth improving, please reach out or comment - I’d love to hear your thoughts!</p>


            </div>
        </section>
        <footer>

            <p>
                    <a href="/"><i class="fa fa-home" aria-hidden="true"></i> Home</a>
                | <a target="_blank" href="https://www.linkedin.com/in/osama-salem-5a432546/"><i class="fa fa-linkedin" aria-hidden="true"></i> LinkedIn</a>
                | <a target="_blank" href="https://github.com/osamasalem"><i class="fa fa-github" aria-hidden="true"></i> Github</a>
                | <a target="_blank" href="https://x.com/MelasAmaso"><i class="fa-brands fa-x-twitter" aria-hidden="true"></i>  X</a>
                | <a target="_blank" href="/about"><i class="fa fa-address-card" aria-hidden="true"></i>  About</a>
            </p>
                <p>Copyright ©  to Osama Salem 2025</p>
            <p>Powered by <a target="_blank" href="https://www.getzola.org/">Zola©</a> </p>

        </footer>
    </div>
</body>

</html>
